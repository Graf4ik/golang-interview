package concurency

import (
	"fmt"
	"sync"
)

//==========================================
//Задача 1
//Что выведет код? Исправить все проблемы
//==========================================

/*
❌ Проблемы:
Канал ch не закрывается — range ch ожидает закрытия канала, но main никогда его не закрывает → бесконечное ожидание.
Горутины могут блокироваться при ch <- v*v, потому что канал небуферизованный, а main не читает из него, пока все wg.Done() не сработают. Это создаёт потенциальный deadlock.
Канал читается после wg.Wait(), но горутины могут быть уже заблокированы при попытке записи в ch.
*/

func main() {
	ch := make(chan int, 3) // Буферизированный канал
	wg := &sync.WaitGroup{}
	wg.Add(3)
	for i := 0; i < 3; i++ {
		go func(v int) {
			defer wg.Done()
			ch <- v * v
		}(i)
	}
	go func() {
		wg.Wait()
		defer close(ch) // Закрываем канал после завершения всех горутин
	}()

	var sum int
	for v := range ch {
		sum += v
	}
	fmt.Printf("result: %d\n", sum)
}
