package concurency

import (
	"fmt"
	"sync"
)

//===========================================================
//Задача 9
//1. Что выведется и как исправить?
//2. Что поправить, чтобы сохранить порядок?
//===========================================================

/*
Проблема с переменной i: Передаем i как параметр в анонимную функцию
Это решает проблему захвата переменной в замыкании
Синхронизация: Добавлен sync.WaitGroup для ожидания завершения всех горутин
Закрываем канал после завершения всех отправок
Сохранение порядка: Используем буферизированный канал как очередь
Выводим сообщения в том же потоке (main), сохраняя порядок
Другие улучшения: Добавлен defer для гарантированного вызова wg.Done()
Используем range для чтения из канала
*/

// Вариант 1
func main() {
	m := make(chan string, 5) // Буфер на все сообщения
	cnt := 5
	for i := 0; i < cnt; i++ {
		go func() {
			m <- fmt.Sprintf("Goroutine %d", i)
		}()
	}
	for i := 0; i < cnt; i++ {
		fmt.Println(<-m)
	}
}

// Вариант 2
func main2() {
	m := make(chan string, 3)
	cnt := 5

	var wg sync.WaitGroup

	for i := 0; i < cnt; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			m <- fmt.Sprintf("Goroutine %d", id)
		}(i) // Передаем i как параметр
	}
	// Получение (в отдельной горутине, чтобы не блокировать main)
	go func() {
		wg.Wait()
		close(m)
	}()

	for msg := range m {
		fmt.Println(msg)
	}

	// Вывод в порядке отправки (используем буферизированный канал)
	//for i := 0; i < cnt; i++ {
	//	go ReceiveFromCh(m)
	//}
}

func ReceiveFromCh(ch chan string) {
	fmt.Println(<-ch)
}
