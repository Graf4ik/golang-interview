package concurency

import (
	"fmt"
	"runtime"
)

//===========================================================
//Задача 19
//Что выведет код и почему?
//===========================================================

/*
Проблемы в коде:
Гонка данных (Data Race)
Переменная ch доступна из двух горутин (main и анонимной) без синхронизации.
Это неопределенное поведение: компилятор/процессор могут оптимизировать код так, что изменения ch в одной горутине не будут видны в другой.
runtime.GOMAXPROCS(1)
При использовании только одного ядра планировщик Go может вообще не переключаться между горутинами, пока main не заблокируется (например, на системном вызове).
В данном случае main занят активным циклом (for ch == 0), поэтому горутина ch = 1 может никогда не выполниться.
Активный цикл (busy loop)
Цикл for ch == 0 не освобождает процессор, поэтому планировщик Go не передает управление другой горутине.
Что выведет программа?

Вариант 1: Бесконечный цикл (гоутина ch = 1 не получает управление).
Вариант 2 (теоретически): Завершится с выводом "finish", если горутина ch = 1 все же выполнится (но это маловероятно при GOMAXPROCS(1)).
*/

func main() {
	runtime.GOMAXPROCS(1)
	ch := 0
	go func() {
		ch = 1
	}()
	for ch == 0 {
	}
	fmt.Println("finish")
}
