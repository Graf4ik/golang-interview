package main

import "fmt"

//==========================================
//Задача 1
//Что выведет код?
//==========================================

type impl struct{}

type I interface {
	C()
}

func (*impl) C() {}

// Типа (dynamic type) — например, *impl.
// Значения (dynamic value) — например, nil или адрес структуры.

func A() I {
	return nil // Возвращает nil типа I (интерфейс без типа и значения).

}
func B() I {
	var ret *impl // ret — указатель на impl, но не инициализирован (nil)
	return ret    // Возвращает nil типа *impl, который реализует I
}

/*
var ret *impl — создает переменную-указатель на impl, но не инициализирует её (значение nil).
При возврате ret (типа *impl) в интерфейс I, интерфейс будет содержать:
Тип: *impl
Значение: nil
*/

func main() {
	a := A()
	b := B()
	fmt.Println(a == b) // false (хотя значение nil, тип *impl есть)
}

/*
Что выведет код?
false, потому что:

a — «чистый» nil интерфейса (nil типа и значения).
b — nil значения, но с типом *impl.
*/
