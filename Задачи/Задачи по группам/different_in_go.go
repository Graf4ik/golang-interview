package main

//===========================================================
//Задача 1
//1. Что выведется?
//===========================================================

//func main() {
//	x := 2.0
//	y := 3.0
//
//	result := math.Pow(x, y) // возведение в степень
//
//	fmt.Println("%f ^ %f = %f\n", x, y, result) // 2 3 8
//}

// ===========================================================
// Задача 2
// 1. Что выведет код?
// ===========================================================
//func main() {
//	fmt.Println("start")
//	for i := 1; i < 4; i++ {
//		defer fmt.Println(i)
//	}
//	fmt.Println("end")
//	// start
//	// end
//	// 3 2 1 в обратном порядке
//}

//===========================================================
//Задача 3
//1. Что будет в результате выполнения теста?
//===========================================================

//type User struct {
//	Valid  bool  // 1 байт + 7 байт padding
//	Id     int64 // 8 байт
//	Number int32 // 4 байта + 4 байта padding
//}
//type CUser struct {
//	Id     int64 // 8 байт
//	Number int32 // 4 байта + 4 байта padding
//	Valid  bool  // 1 байт + 7 байт padding
//}
//
//func TestSize(t *testing.T) {
//	user := User{}
//	cuser := CUser{}
//	if unsafe.Sizeof(user) == unsafe.Sizeof(cuser) {
//		t.Log("structs size are equal") // false, т.к. разный порядок полей
//	}
//}

//===========================================================
//Задача 4
//1. Какие строки работают нормально, а какие нет и почему?
//===========================================================

//type T []int
//
//func (T) X()  {}
//func (*T) Z() {}
//
//func main() {
//	var t T
//	t.X() // 1 Метод X определён на значении, поэтому работает нормально. +
//	t.Z() // 2 t — значение, а метод Z — с указателем.Допустимо: компилятор автоматически берёт адрес &t для вызова Z. +
//	var p = &t
//	p.X()   // 3 p — указатель на T, метод X — для значения. Допустимо: компилятор автоматически разыменовывает p. +
//	p.Z()   // 4 p — указатель, метод Z — для указателя. Всё точно совпадает, нормально работает. +
//	T{}.X() // 5 T{} — литерал пользовательского типа T, метод X — для значения +
//	T{}.Z() // 6 T{} — значение, метод Z ожидает указатель (*T). -
//	// В отличие от t.Z() (где t — переменная), у литерала нельзя взять адрес (&T{} недопустимо). -
//	// Компилятор не может автоматически взять адрес литерала, поэтому -
/*Литерал значения — это "одноразовое" значение, созданное прямо в коде. О
но удобно, но с ним нельзя делать всё, что можно с переменными — например, нельзя взять его адрес,
что важно при вызове методов с указателем-получателем (*T). */
//}

//===========================================================
//Задача 5
//1. Расскажи подробно что происходит
//2. Как сделать так, чтобы работало?
//===========================================================

//func main() {
//	str := "Привет"
//	runes := []rune(str) // превращаем в срез рун (каждая руна — символ)
//	runes[2] = 'е'
//	str = string(runes) // Обратно в строку
//	// str[2] = 'e'
//	fmt.Println(str)
//	// string — это срез байтов ([]byte), но в UTF-8 один символ может занимать несколько байтов.
//	// rune — это int32, представляющий Юникод-символ целиком.
//}

// ===========================================================
// Задача 6
// Что выведет код и почему?
// ===========================================================
//func main() {
//	a := []int{10, 20, 30, 40}
//	b := make([]*int, len(a)) // len = 4
//	for i, v := range a {     // v — это копия значения a[i], и она одна на всю итерацию
//		b[i] = &v // &v во всех итерациях ссылается на один и тот же адрес,
//		// который на каждой итерации содержит новое значение.
//	}
//	fmt.Println(*b[0], *b[1]) // 10 20 или 40 40
//}
