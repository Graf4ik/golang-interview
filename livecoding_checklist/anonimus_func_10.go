package livecoding_checklist

import (
	"fmt"
	"os"
	"sort"
	"time"
)

// 10. Анонимные функции - создание, вызов с аргументами, захват значений.

// Анонимные функции (лямбда-функции) в Go - это функции без имени,
//которые могут быть определены и вызваны непосредственно в месте использования.

func main() {
	// 1. Базовое создание и вызов
	// Определение и немедленный вызов
	func() {
		fmt.Println("Анонимная функция вызвана")
	}() // Скобки в конце означают вызов

	// С аргументами
	func(name string) {
		fmt.Printf("Привет, %s!\n", name)
	}("Иван") // Передаем аргумент при вызове

	// 2. Присваивание переменной и отложенный вызов
	// Присваиваем анонимную функцию переменной
	greet := func(name string) {
		fmt.Printf("Привет, %s!\n", name)
	}

	greet("Анна") // Вызываем через переменную

	// Отложенный вызов (defer)
	defer func() {
		fmt.Println("Эта функция выполнится при завершении")
	}()

	// 3. Захват переменных из окружающего контекста (замыкание)
	counter := 0

	// Функция захватывает переменную counter
	increment := func() {
		counter++
		fmt.Println("Счетчик:", counter)
	}

	increment() // Счетчик: 1
	increment() // Счетчик: 2

	// 4. Возврат анонимной функции из функции
	double := makeMultiplier(2)
	triple := makeMultiplier(3)

	fmt.Println(double(5)) // 10
	fmt.Println(triple(5)) // 15

	// 5. Использование в горутинах
	for i := 0; i < 3; i++ {
		go func(num int) {
			fmt.Printf("Горутина %d\n", num)
		}(i) // Важно передать i как аргумент
	}

	time.Sleep(time.Second)

	// 6. Захчет переменных в цикле (важный нюанс)
	var funcs []func()

	for i := 0; i < 3; i++ {
		// Неправильно: все функции захватят одно и то же i
		// funcs = append(funcs, func() { fmt.Println(i) })

		// Правильно: передаем текущее значение как аргумент
		j := i // Создаем новую переменную для каждой итерации
		funcs = append(funcs, func() { fmt.Println(j) })
	}

	for _, f := range funcs {
		f() // Выведет 0, 1, 2
	}

	// 7. Практические примеры использования
	// Сортировка с кастомным компаратором:
	people := []struct {
		Name string
		Age  int
	}{
		{"Алиса", 25},
		{"Боб", 30},
		{"Кэрол", 20},
	}

	sort.Slice(people, func(i, j int) bool {
		return people[i].Age < people[j].Age
	})

	fmt.Println(people) // [{Кэрол 20} {Алиса 25} {Боб 30}]
}

// Обработка ошибок с defer:
func processFile(path string) (err error) {
	file, err := os.Open(path)
	if err != nil {
		return err
	}

	defer func() {
		closeErr := file.Close()
		if err == nil { // Если нет другой ошибки
			err = closeErr // Сохраняем ошибку закрытия
		}
	}()

	// Работа с файлом...
	return nil
}

func makeMultiplier(factor int) func(int) int {
	// Возвращаемая функция захватывает factor
	return func(x int) int {
		return x * factor
	}
}

/*
8. Особенности анонимных функций в Go

Замыкания: Анонимные функции могут захватывать переменные из окружающего контекста
Гибкость: Могут быть вызваны сразу, присвоены переменной или возвращены из другой функции
Использование:
Отложенные операции (defer)
Горутины
Коллбэки
Инкапсуляция логики

Захват переменных:
	Захватываются по ссылке
	Важно правильно передавать переменные в цикле
Производительность: Немного менее эффективны, чем именованные функции

Анонимные функции - мощный инструмент в Go, который особенно полезен для:
Создания замыканий
Реализации callback-ов
Инкапсуляции логики
Работы с горутинами
Создания специализированных функций "на лету"
*/
