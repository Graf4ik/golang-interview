package livecoding_checklist

import (
	"io"
	"net"
	"os"
	"sync"
)

// 11. Использование defer для закрытия каналов, освобождения ресурсов.

// Ключевое слово defer в Go позволяет отложить выполнение
// функции до момента завершения окружающей функции. Это особенно полезно для
// управления ресурсами и обеспечения их корректного освобождения.

// Закрытие каналов с defer
// Для каналов defer часто используется для гарантированного закрытия:
func processJobs(jobs <-chan int, results chan<- int) {
	defer close(results) // Закроем канал результатов при выходе из функции

	for job := range jobs {
		results <- job * 2 // Обработка задания
	}
}

// Преимущества:
// Канал будет закрыт даже при панике
// Код становится более читаемым - ресурс освобождается сразу после его создания
// Исключаются утечки ресурсов

// Освобождение других ресурсов
// defer можно использовать для различных видов очистки:
// Файлы

func readFile(filename string) (string, error) {
	f, err := os.Open(filename)
	if err != nil {
		return "", err
	}
	defer f.Close() // Гарантированное закрытие файла

	content, err := io.ReadAll(f)
	if err != nil {
		return "", err
	}

	return string(content), nil
}

// Мьютексы
var mu sync.Mutex
var data map[string]int

func updateData(key string, value int) {
	mu.Lock()
	defer mu.Unlock() // Разблокировка после завершения

	data[key] = value
}

// Сетевые соединения
func handleConnection(conn net.Conn) {
	defer conn.Close() // Закрытие соединения при выходе

	// Работа с соединением
	buf := make([]byte, 1024)
	for {
		n, err := conn.Read(buf)
		if err != nil {
			return
		}
		// Обработка данных
	}
}

/*
Особенности использования defer
Порядок выполнения: defer выполняются в порядке LIFO (последний добавленный - первый выполненный)
Аргументы вычисляются немедленно: аргументы отложенной функции вычисляются в момент вызова defer, а не при выполнении
Не подходит для долгих операций: не стоит использовать defer для операций, которые могут занимать значительное время
Использование defer делает код более надежным и читаемым, особенно при работе с ресурсами, которые требуют обязательного освобождения.
*/
func main() {

}
