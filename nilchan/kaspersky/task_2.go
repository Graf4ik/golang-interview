package kaspersky

import "fmt"

// что выведет, почему, что если не будем закрывать stopChan, что будет если введем default?

func main() {
	msgChan := make(chan string, 1)
	close(msgChan)
	stopChan := make(chan struct{})
	close(stopChan)

	select {
	case msgChan <- "msg":
		fmt.Println("msg sent")
	case <-stopChan:
		fmt.Println("stop channel received")
	}
} //  res: stop channel received

/*
Причины:

Канал msgChan закрыт, поэтому попытка отправить в него сообщение (msgChan <- "msg") вызовет панику. Однако в select:
Если несколько case готовы к выполнению, select выбирает случайный
Закрытый канал в операции приёма (<-stopChan) всегда готов
Операция отправки в закрытый канал - невалидна
Поэтому select выбирает case с stopChan, так как он закрыт и готов к чтению (возвращает нулевое значение struct{})
*/

// 1. Если не закрывать stopChan: panic: send on closed channel
/*
Почему:
msgChan закрыт, отправка в закрытый канал вызывает панику
stopChan не готов (не закрыт и в него никто не отправляет)
В select остаётся только невалидная операция отправки → паника
*/

// 2. Если добавить default:
// default:
// fmt.Println("default case")
// Результат: stop channel received

// 3. Если не закрывать каналы и добавить default:
// default:
// fmt.Println("default case")
// default case

/*
Почему:

Ни msgChan (буферизированный, но пустой), ни stopChan не готовы
Поэтому выполняется default

Выводы:
Отправка в закрытый канал вызывает панику
Чтение из закрытого канала всегда готово (возвращает нулевое значение)
В select при нескольких готовых case выбор случайный
default выполняется только если ни один case не готов
Закрытие каналов существенно влияет на поведение select

Лучшие практики:
Не пытайтесь отправлять в закрытые каналы
Всегда проверяйте, не закрыт ли канал, если есть вероятность
Используйте default для неблокирующих операций
Закрывайте каналы только тогда, когда точно уверены, что больше не будет отправок
*/
