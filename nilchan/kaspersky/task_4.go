package kaspersky

// как компилятор будет выделять и что выведет

func main() {
	a := make([]int) // Ошибка компиляции: missing len argument to make
	for {
		a = append(a, 1)
	}

	// a := make([]int, 0)  // Пустой слайс
	// for {
	//	 a = append(a, 1) // Бесконечное добавление
	// }
}

// Функция make для слайсов требует либо:
// Только длины: make([]int, length)
// Длины и ёмкости: make([]int, length, capacity)
/*

/*
Правильные варианты:
a := make([]int, 0)      // Слайс с длиной 0
a := make([]int, 0, 10)  // Слайс с длиной 0 и ёмкостью 10
*/

/*
Что будет происходить:
Выделение памяти:
Go динамически управляет памятью для слайсов
При append если ёмкости недостаточно, выделяется новый массив большего размера
Обычно ёмкость увеличивается по формуле (примерно в 2 раза при достижении предела)

Поведение программы:
Программа будет бесконечно добавлять элементы в слайс
Периодически будет происходить переаллокация памяти
В конечном итоге программа завершится с ошибкой:

fatal error: runtime: out of memory
Выделение памяти под капотом:
Первоначально слайс имеет длину 0 и ёмкость 0
Первый append выделит базовый массив ёмкостью 1
При заполнении ёмкость будет увеличиваться примерно по схеме: 1, 2, 4, 8, 16, 32,...
*/

/*
Выводы:
Исходный код не скомпилируется из-за неправильного использования make
После исправления программа будет бесконечно добавлять элементы
Go автоматически управляет увеличением ёмкости слайса
В реальности программа завершится с ошибкой нехватки памяти
Стратегия увеличения ёмкости может различаться в разных версиях Go
*/
