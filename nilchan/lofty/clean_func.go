package lofty

import "fmt"

// чистая ли эта функция, и какие выводы будут. Как можно исправить
func main() {
	sl := []int{1, 2, 3, 4, 5}
	res := sliceWithout(sl, 1) // sl: [1 3 4 5], res: [1 3 4 5]
	res = sliceWithout(res, 1) // res: [1 4 5]

	fmt.Println(sl, res) // [1 4 5 5 5] [1 4 5]
}

// Чтобы избежать мутации оригинального массива:
//func sliceWithout(slice []int, index int) []int {
//	result := make([]int, 0, len(slice)-1)
//	result = append(result, slice[:index]...)
//	result = append(result, slice[index+1:]...)
//	return result
//}

func sliceWithout(slice []int, index int) []int {
	return append(slice[:index], slice[index+1:]...)
}

/*
Что происходит пошагово:
Шаг 1. sl := []int{1, 2, 3, 4, 5}
	sl указывает на массив [1 2 3 4 5]
	len(sl) = 5, cap(sl) = 5

Шаг 2. res := sliceWithout(sl, 1)
	Вызов append(slice[:1], slice[2:]...) => append([1], [3 4 5]) => [1 3 4 5]
	При этом в слайсе хватает capacity, поэтому Go НЕ аллоцирует новый массив.
	append перезаписывает элементы внутри массива sl, начиная с index = 1.
	Итог: и sl, и res делят один и тот же массив.
	Теперь sl уже выглядит как [1 3 4 5 5] (5 остался на старом месте, но не был затронут).

Шаг 3. res = sliceWithout(res, 1)
	В res сейчас [1 3 4 5], len = 4, cap = 5 — всё ещё достаточно capacity, чтобы не аллоцировать новый массив.
	append([1], [4 5]) => [1 4 5]
	Опять же, запись идёт в тот же массив, перезаписывая позиции [1], [2], [3]

Результат:

res: [1 4 5]
sl: теперь в виде [1 4 5 5 5] — потому что изменения в res перезаписали содержимое базового массива, который всё ещё используется в sl.
Почему [1 4 5 5 5], а не [1 4 5]?
Потому что len(sl) остаётся 5, даже если его содержимое мутировало. А append не обнуляет остаток старых значений
в массиве (на позициях, которые уже не используются новым слайсом), и мы их видим при печати sl.
*/
