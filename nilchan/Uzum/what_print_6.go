package Uzum

// что выведет
func main() {
	ch := make(chan int, 1)
	ch <- 1
	for i := 0; i < 10; i++ {
		select {
		case x := <-ch:
			println(x)
		case ch <- i:
		}
	}
}

/*
Итерация 1 (i == 0):
Канал содержит 1, он не пустой, значит можно выполнить x := <-ch, и x == 1.
→ Вывод: 1

Теперь канал пуст. ch = []
Далее (i == 1..9):
На каждой итерации:
select случайным образом выбирает доступную ветку:
ch <- i доступна (канал пуст — можно писать).
x := <-ch тоже доступна (если в прошлой итерации туда что-то записали).
Но вывод будет происходить только если x := <-ch сработал, а это не гарантировано.
Возможное поведение:
Запись в канал (ch <- i) выполняется.
На следующей итерации может сработать x := <-ch → тогда будет println(i).
Но ничто не гарантирует, что select выберет x := <-ch хотя бы один раз — особенно если сначала будет много ch <- i.

Итог:
Гарантированно будет выведено 1.
Остальные значения — непредсказуемы, зависят от выбора ветки в select.
Возможен вывод нескольких значений или только одного (1).
*/
